#' @title Obtain read level cluster memberships using a fitted GoM model from
#' a MutSignature file.
#'
#'
#' @description Performs a read level cluster membership assignment using the
#' fitted model from \code{aRchiac_cluster()} for each read with mismatch in a
#' BAM file. The BAM file is first processed to obtain the mutSignature file
#' which is taken as an input for this function along with a fitted GoM model.
#'
#' @param fit a Grade of Membership model saved under \code{model.rda} produced
#' as output by \code{aRchaic_cluster()} function. The mutation signature
#' labels must be provided with the \code{theta} matrix of this object.
#'
#' @param reads_file A mutSignature file (.csv) file generated by applying
#' `generate_summary_bams` on the BAM file.
#'
#' @param num_cores The number of cores to be used for parallel processing.
#' If NULL, all detectable cores are used.
#'
#' @param subset The number of reads to be subsetted. Applicable when the user
#' is interested in learning the cluster memberships of only a handful of reads.
#'
#' @param verbose if TRUE, the function returns the total time system time taken.
#'
#' @param nostrand if FALSE, the strand information is considered as well
#' in the computation of the cluster membership probabilities. If TRUE,
#' the strand information is ignored.
#'
#' @return Produces a matrix with each row containing the cluster memberships
#' of a read, the mutation signatures observed in that read along with the
#' read ID.
#'
#' @keywords read_memberships
#' @import parallel
#' @export



read_memberships <- function(fit,
                               reads_file,
                               num_cores = NULL,
                               subset = NULL,
                               verbose = TRUE,
                               nostrand = FALSE){

  argl <- list()

  theta <- fit$theta
  rownames <- rownames(theta)
  topic_break <- theta_breakdown(theta)

  reads_collection <- reads_file

  read_id <- unique(reads_collection[,7])
  if(!is.null(subset)){
    if(subset < length(read_id)){
      indices <- sample(1:length(read_id), subset, replace = FALSE)
      read_id <- read_id[indices]
    }
  }

  if(is.null(num_cores)){
    cl <- parallel::makeCluster(parallel::detectCores(),type=ifelse(.Platform$OS.type=="unix","FORK","PSOCK"))
    print(cl)
  }else{
    cl <- parallel::makeCluster(num_cores,type=ifelse(.Platform$OS.type=="unix","FORK","PSOCK"))
    print(cl)
  }

  argl$reads_collection <- reads_collection
  argl$nostrand <- nostrand
  argl$topic_break <- topic_break
  if(verbose){
    system.time(read_member_mat <- as.data.frame(do.call(rbind,
                  parLapply(cl, read_id, fun = read_probability, argl)),
                  stringsAsFactors = FALSE))
  }else{
    read_member_mat <- as.data.frame(do.call(rbind,
              parLapply(cl, read_id, fun = read_probability, argl)),
              stringsAsFactors = FALSE)
  }
  colnames(read_member_mat) <- c(paste("cl-", 1:dim(theta)[2]), "sig", "ID")
  return(read_member_mat)
}



read_probability <- function(read_x, argl){
  idx <- which(argl$reads_collection[, 7] == read_x)
  reads <- argl$reads_collection[idx,]
  dist <-  as.numeric(apply(as.matrix(reads), 1, function(x) return(min(x[2], x[3]))))
  modf <- cbind.data.frame(paste0(reads[,1], "_", reads[,6], "_", reads[,4], "_", reads[,5], "_", dist))
  colnames(modf) <- "signature"
  modf2 <- as.character(modf[,1])
  symbol_vec <- signatureclub3(modf2, flanking_bases =  1)

  sym_prob <- array(1, length(argl$topic_break))
  for(v in 1:length(symbol_vec)){
    if(argl$nostrand){
      sym_prob <- tryCatch(sym_prob * get_prob_symbol(argl$topic_break, as.character(symbol_vec[v])),
                           error = function(e){sym_prob <- sym_prob})
    }else{
      sym_prob <- tryCatch(sym_prob * get_prob_symbol_nostrand(argl$topic_break, as.character(symbol_vec[v])),
                           error = function(e){sym_prob <- sym_prob})
    }
  }
  sym_prob <- sym_prob/sum(sym_prob)
  sym_prob <- round(sym_prob, 4)
  sym_prob <- sym_prob/sum(sym_prob)

  sym_prob_2 <- c(sym_prob, paste0(symbol_vec, collapse = " ; "), read_x)
  return(sym_prob_2)
}


gsub3 <- function(pattern, replacement, x, ...) {
  for(i in 1:length(pattern))
    x <- chartr(pattern[i], replacement[i], x, ...)
  x
}

signatureclub3 <- function(signature_set, flanking_bases){
  from <- c('A','T','G','C')
  to <- c('t','a','c','g');
  signature_set_mod <- array(0, length(signature_set));
  for(m in 1:length(signature_set)){
    if(substring(signature_set[m], (1+flanking_bases), (1+flanking_bases)) == "A" | substring(signature_set[m], (1+flanking_bases), (1+flanking_bases)) == "G"){
      temp_split <- strsplit(as.character(signature_set[m]), split="")[[1]]
      bases_flanked <- toupper(gsub3(from, to, substring(signature_set[m], 1, (4+2*flanking_bases))))
      temp_split[1:(4+2*flanking_bases)] <- strsplit(as.character(bases_flanked), split="")[[1]]
      side1 <- temp_split[1:flanking_bases]
      side2 <- temp_split[(5+flanking_bases):(4+2*flanking_bases)]
      temp_split[(5+flanking_bases):(4+2*flanking_bases)] <- rev(side1)
      temp_split[1:flanking_bases] <- rev(side2)
      sign <- temp_split[6+2*flanking_bases]
      if(sign == "+"){
        breakbase <- temp_split[8+2*flanking_bases]
      }else if (sign == "-"){
        breakbase <- toupper(to[match(temp_split[10+2*flanking_bases], from)])
      }
    }else{
      temp_split <- strsplit(as.character(signature_set[m]), split="")[[1]]
      sign <- temp_split[6+2*flanking_bases]
      if(sign == "+"){
        breakbase <- temp_split[8+2*flanking_bases]
      }else if (sign == "-"){
        breakbase <- toupper(to[match(temp_split[10+2*flanking_bases], from)])
      }
    }
    temp_new <- paste0(c(temp_split[1:(7+2*flanking_bases)], breakbase, temp_split[(11+2*flanking_bases):(length(temp_split))]), collapse = "")
    signature_set_mod[m] <- temp_new
  }
  return(signature_set_mod)
}


get_prob_symbol <- function(broken_topics, symbol){

  left_flank <- substring(as.character(symbol), 1,1)
  mismatch <- substring(as.character(symbol), 2, 5)
  right_flank <- substring(as.character(symbol), 6, 6)
  strand <- substring(as.character(symbol), 8, 8)
  if(strand == "+"){strand <- "plus"}else{strand = "minus"}
  strand_break <- substring(as.character(symbol), 10, 10)
  pos <- as.numeric(unlist(strsplit(as.character(symbol), "[_]")[[1]])[4])

  if(pos > 20){
    pos <- 20
  }

  net_prob <- array(0, length(broken_topics))

  for(m in 1:length(broken_topics)){
    ll <- broken_topics[[m]]
    net_prob[m] <- as.numeric(ll$`mismatch-flank`[paste0(left_flank),1] *
                                ll$`mismatch-flank`[paste0(right_flank),3] *
                                ll$`mismatch-flank`[paste0(mismatch),2] *
                                ll$`strand-break-composition`[paste0(strand_break),1] *
                                as.numeric(ll$`strand-orientation`[paste0(strand)]) *
                                ll$`mismatch-trend-read`[pos])

  }

  return(net_prob)
}


get_prob_symbol_nostrand <- function(broken_topics, symbol){

  left_flank <- substring(as.character(symbol), 1,1)
  mismatch <- substring(as.character(symbol), 2, 5)
  right_flank <- substring(as.character(symbol), 6, 6)
  pos <- as.numeric(unlist(strsplit(as.character(symbol), "[_]")[[1]])[4])

  if(pos >= 20){
    pos <- 20
  }

  net_prob <- array(0, length(broken_topics))

  for(m in 1:length(broken_topics)){
    ll <- broken_topics[[m]]
    net_prob[m] <- as.numeric(ll$`mismatch-flank`[paste0(left_flank),1] *
                                ll$`mismatch-flank`[paste0(right_flank),3] *
                                ll$`mismatch-flank`[paste0(mismatch),2] *
                                ll$`mismatch-trend-read`[pos])

  }

  return(net_prob)
}



